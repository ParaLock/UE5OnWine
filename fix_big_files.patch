diff --git a/Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformFile.cpp b/Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformFile.cpp
index 577f0ae20fc4..d44c13802875 100644
--- a/Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformFile.cpp
+++ b/Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformFile.cpp
@@ -701,57 +701,73 @@ public:
 		TRACE_PLATFORMFILE_END_READ(&OverlappedIO, TotalNumRead);
 		return true;
 	}
-	virtual bool Write(const uint8* Source, int64 BytesToWrite) override
-	{
-		check(IsValid());
 
-		TRACE_PLATFORMFILE_BEGIN_WRITE(this, FileHandle, FilePos, BytesToWrite);
+	bool WriteBytes(const uint8* Source, int64 BytesToWrite, OVERLAPPED* POverlapped, bool& TryNonOverlapped) {
 
-		int64 TotalNumWritten = 0;
+		uint32 NumWritten = 0;
 		do
 		{
 			uint32 BytesToWrite32 = (uint32)FMath::Min<int64>(BytesToWrite, int64(UINT32_MAX));
-			uint32 NumWritten = 0;
-			// Now kick off an async write
-			if (!WriteFile(FileHandle, Source, BytesToWrite32, (::DWORD*)&NumWritten, &OverlappedIO))
+			if (!WriteFile(FileHandle, Source, BytesToWrite32, (::DWORD*)&NumWritten, POverlapped))
 			{
 				uint32 ErrorCode = GetLastError();
 				if (ErrorCode != ERROR_IO_PENDING)
 				{
-					// Write failed
-					TRACE_PLATFORMFILE_END_WRITE(this, 0);
 					return false;
 				}
-				// Wait for the write to complete
 				NumWritten = 0;
 				if (!GetOverlappedResult(FileHandle, &OverlappedIO, (::DWORD*)&NumWritten, true))
 				{
-					// Write failed
-					TRACE_PLATFORMFILE_END_WRITE(this, 0);
 					return false;
 				}
 			}
 	
 			BytesToWrite -= BytesToWrite32;
 			Source += BytesToWrite32;
-			TotalNumWritten += NumWritten;
-			// Update where we are in the file
 			FilePos += NumWritten;
 			UpdateOverlappedPos();
 			FileSize = FMath::Max(FilePos, FileSize);
 			
-			// Early out as a failure case if we didn't write all of the data we expected
 			if (BytesToWrite32 != NumWritten)
 			{
-				TRACE_PLATFORMFILE_END_WRITE(this, TotalNumWritten);
+				TryNonOverlapped = true;
 				return false;
 			}
 			
 		} while (BytesToWrite > 0);
 
-		TRACE_PLATFORMFILE_END_WRITE(this, TotalNumWritten);
 		return true;
 	}
+
+	virtual bool Write(const uint8* Source, int64 BytesToWrite) override
+	{
+		check(IsValid());
+
+		int64 TempFileSize = FileSize;
+		int64 TempFilePos = FilePos;
+		bool TryNonOverlapped = false;
+
+		OVERLAPPED* POverlapped = &OverlappedIO;
+
+		bool WriteResult = WriteBytes(Source, BytesToWrite, POverlapped, TryNonOverlapped);
+
+		if(WriteResult) {
+			return true;
+		}
+
+		if(!WriteResult && !TryNonOverlapped) {
+			return false;
+		}
+
+		if(TryNonOverlapped) {
+			FileSize = TempFileSize;
+			Seek(TempFilePos);
+			UpdatedNonOverlappedPos();
+			POverlapped = nullptr;
+		}
+
+		return WriteBytes(Source, BytesToWrite, POverlapped, TryNonOverlapped);
+	}
 	virtual bool Flush(const bool bFullFlush = false) override
 	{
 		check(IsValid());
